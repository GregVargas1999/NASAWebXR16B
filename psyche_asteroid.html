<!DOCTYPE html>
<html>

<head>
	<base href="./">
	<meta charset="utf-8">
	<title>psyche_asteroid</title>
	<style>
		body {
			margin: 0;
		}

		canvas {
			display: block;
		}

		#c {
			width: 100vw;
			height: 100vh;
			display: block;
			background: url(images/facepalm.png) no-repeat center center;
			background-size: cover;
		}
	</style>
</head>

<body>

	<script type="module">

	import * as THREE from '../build/three.module.js';

	import {OrbitControls} from './jsm/controls/OrbitControls.js';
	import {GLTFLoader} from './jsm/loaders/GLTFLoader.js';

	var container, controls;
	var camera, scene, renderer;

	init();
	animate();

	function init() 
	{
		container = document.createElement('div');
		document.body.appendChild(container);

		camera = new THREE.PerspectiveCamera(45, window.innerWidth / window.innerHeight, 1, 50000);
		camera.position.set(3, 0, 3);

		scene = new THREE.Scene();
		scene.add(new THREE.HemisphereLight(0xFFFFFF, 0xFFFFFF, 0.5));
		scene.add(new THREE.DirectionalLight(0xffe3ab, 0.25));

		var particleGeom = new THREE.Geometry();
		var particleMaterial = new THREE.PointsMaterial({
			color: 'rgb(80, 130, 255)',
			size: 50,
			map: new THREE.TextureLoader().load('textures/lensflare/lensflare0.png'),
			transparent: true,
			blending: THREE.AdditiveBlending,
		});

		let particleCount = 100000;
		let min = 10000;
		let max = 40000;
		let theta = THREE.Math.randFloatSpread(360);
		let phi = THREE.Math.randFloatSpread(360);

		for (var i = 0; i < particleCount; i++) 
		{
			let posX = min + ((Math.random() - 0.5) * max);
			let posY = min + ((Math.random() - 0.5) * max);
			let posZ = min + ((Math.random() - 0.5) * max);
			
			let particle = new THREE.Vector3(posX, posY, posZ);
			particleGeom.vertices.push(particle);
		}

		let particleSys = new THREE.Points(particleGeom, particleMaterial);
		particleSys.name = 'particleSys';
		scene.add(particleSys);

		var loader = new GLTFLoader().setPath('models/');
		loader.load( 'asteroid.glb', function (gltf) 
		{
			scene.add( gltf.scene );
			animate();
		});

		renderer = new THREE.WebGLRenderer({antialias: true});
		renderer.setPixelRatio(window.devicePixelRatio);
		renderer.setSize(window.innerWidth, window.innerHeight);
		renderer.toneMapping = THREE.ACESFilmicToneMapping;
		renderer.toneMappingExposure = 1;
		renderer.outputEncoding = THREE.sRGBEncoding;
		container.appendChild(renderer.domElement);

		var pmremGenerator = new THREE.PMREMGenerator(renderer);
		pmremGenerator.compileEquirectangularShader();

		controls = new OrbitControls(camera, renderer.domElement);
		controls.addEventListener('change', render); // use if there is no animation loop
		controls.update();

		window.addEventListener('resize', onWindowResize, false);
	}

	function onWindowResize() 
	{
		camera.aspect = window.innerWidth / window.innerHeight;
		camera.updateProjectionMatrix();

		renderer.setSize( window.innerWidth, window.innerHeight );

		animate();
	}

	function animate() 
	{
		var rotSpeed = 0.002;

		let x = camera.position.x;
		let z = camera.position.z;
		camera.position.x = x * Math.cos(rotSpeed) + z * Math.sin(rotSpeed);
		camera.position.z = z * Math.cos(rotSpeed) - x * Math.sin(rotSpeed);
		camera.lookAt(scene.position);

		requestAnimationFrame(animate);
		renderer.render(scene, camera);
	}
	</script>
</body>

</html>