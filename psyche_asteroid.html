<!DOCTYPE html>
<html>

<head>
	<base href="./">
	<meta charset="utf-8">
	<title>psyche_asteroid</title>
	<style>
		body {
			margin: 0;
		}

		canvas {
			display: block;
		}

		#c {
			width: 100vw;
			height: 100vh;
			display: block;
			background: url(images/facepalm.png) no-repeat center center;
			background-size: cover;
		}
	</style>
</head>

<body>
	<!---Div to implement scene transition controls-->
	<div class="container" style="margin: auto; display: block; ">
		<h1 style="position: absolute; display: block; z-index: 99; top: 0; left: 0%;" class="text-primary"><a href="basic3DEnvironment.html"><img style="max-width: 15%;" src="https://i.imgur.com/EucPFyl.png"></a></img></h1>
		<h1 style="text-align: right; position: absolute; display: block; z-index: 99; top: 0; right: 0%;" class="text-primary"><a href="psyche_satellite.html"><img style="max-width: 15%;" src="https://i.imgur.com/gmi8iEd.png"></a></img></h1>
	</div>

	<script type="module">

	import * as THREE from 'https://unpkg.com/three@0.121.1/build/three.module.js';

	import { OrbitControls } from 'https://unpkg.com/three@0.121.1/examples/jsm/controls/OrbitControls.js';
	import { GLTFLoader } from 'https://unpkg.com/three@0.121.1/examples/jsm/loaders/GLTFLoader.js';

	var container, controls;
	var camera, scene, renderer;
	var model, newMin;
	var ambientLight, pointLight;

	init();
	animate();

	function init() 
	{
		container = document.createElement('div');
		document.body.appendChild(container);

		camera = new THREE.PerspectiveCamera(45, window.innerWidth / window.innerHeight, 1, 100000);
		camera.position.set(3, 0, 3);

		// This creates a soft light so that shadows are less harsh
		scene = new THREE.Scene();
		ambientLight = new THREE.AmbientLight(0xFFFFFF, 0.05);
		scene.add(ambientLight);
		
		// Point light is similar to directional light, I'm using realistic setting for light falloff
		// PointLight( color : Integer, intensity : Float, distance : Number, decay : Float )
		pointLight = new THREE.PointLight(0xFFFFFF, 1, 0, 2);
		pointLight.position.set(-3,6,-3);
		scene.add(pointLight);

		var particleGeom = new THREE.Geometry();
		var particleMaterial = new THREE.PointsMaterial({
			color: 'rgb(80, 130, 255)',
			size: 50,
			map: new THREE.TextureLoader().load('textures/lensflare0.png'),
			transparent: true,
			blending: THREE.AdditiveBlending,
		});

		// Plotting particles at -(min to max) and (min to max)
		let particleCount = 10000;
		let min = 100;
		let max = 10000;

		for (var i = 0; i < particleCount; i++) 
		{
			let posX = (getRandom(min) * (2 * (max - min))) + newMin;
			let posY = (getRandom(min) * (2 * (max - min))) + newMin;
			let posZ = (getRandom(min) * (2 * (max - min))) + newMin;
			
			let particle = new THREE.Vector3(posX, posY, posZ);
			particleGeom.vertices.push(particle);
		}

		let particleSys = new THREE.Points(particleGeom, particleMaterial);
		particleSys.name = 'particleSys';
		scene.add(particleSys);

		var loader = new GLTFLoader().setPath('models/');
		loader.load('asteroid.glb', function (gltf) 
		{
			model = gltf.scene
			scene.add(model);
			animate();
		});

		renderer = new THREE.WebGLRenderer({antialias: true});

		renderer.setPixelRatio(window.devicePixelRatio);
		renderer.setSize(window.innerWidth, window.innerHeight);

		renderer.toneMapping = THREE.ACESFilmicToneMapping;
		renderer.toneMappingExposure = 1;

		renderer.shadowMap.enabled = true;
		renderer.shadowMap.type = THREE.BasicShadowMap;

		renderer.outputEncoding = THREE.sRGBEncoding;
		container.appendChild(renderer.domElement);

		var pmremGenerator = new THREE.PMREMGenerator(renderer);
		pmremGenerator.compileEquirectangularShader();

		controls = new OrbitControls(camera, renderer.domElement);
		controls.addEventListener('change', render); // use if there is no animation loop
		controls.update();

		window.addEventListener('resize', onWindowResize, false);
	}

	function getRandom(number)
	{
		let rand = (Math.random() - 0.5);
		newMin = number;

		if(rand < 0)
		{
			newMin *= -1;
		}

		return rand;
	}

	function onWindowResize() 
	{
		camera.aspect = window.innerWidth / window.innerHeight;
		camera.updateProjectionMatrix();

		renderer.setSize( window.innerWidth, window.innerHeight );

		animate();
	}

	function animate() 
	{
		var rotSpeed = 0.001;

		model.rotation.x += rotSpeed;
		model.rotation.y += rotSpeed;

		requestAnimationFrame(animate);
		renderer.render(scene, camera);
	}
	</script>
</body>

</html>